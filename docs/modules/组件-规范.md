组件由 3 部分构成. js api ,ios 实现, android 实现.

![image-20200719163238615](assets/image-20200719163238615.png)

组件模板会多包含一层 x-engine, 以供开发者调试测试用. 在发布后将不会包含. 见下文[模板目录结构].



**重点：组件禁止依赖组件。 组件必须依赖接口，接口定义在 x-engine-module-protocols 内。**



## 模板目录结构

- x-engine-module-engine
  - iOS
    - podfile
  - android
    - app
      - build.gradle
    - build.gradle
  - h5
    - index.js
    - package.json
  - README.md
  - [module.json](./docs/configfile/config.md#module.json)




## 权限申请

iOS: 按本地应用申请即可.

android: https://developer.android.google.cn/training/permissions/usage-notes#dont-overwhelm

### 权限询问的时机

|         | CRITICAL                         | CRITICAL          |       |
| ------- | -------------------------------- | ----------------- | ----- |
| UNCLEAR | 启动时,告诉用户为什么需要,弹出   | 启动时,直接弹出   | CLEAR |
| UNCLEAR | 在使用时,告诉用户为什么需要,弹出 | 在使用时,直接弹出 | CLEAR |
|         | NON-CRITICAL                     | NON-CRITICAL      |       |



## 组件分类

* 通用组件

  直接集成到应用开发模板工程里. 稳定性好.有良好的集成测试.

* 可选组件

  需要用户自己手动注册, 各插件件的兼容性并没得到很好测试, 但一般都可正常使用.

## 版本号约定

将使用 git tag 打上版本, 比如 **git tag 1.0.0**

<大版本>.<中版本>.<小版本>

|        | api 返回值修改 | api 增加 | api 删除 | api 修内部 bug |
| ------ | -------------- | -------- | -------- | -------------- |
| 大版本 | ^              |          | ^        |                |
| 中版本 |                | ^        |          |                |
| 小版本 |                |          |          | ^              |





## js API 约束

约定所有 js API 统一采用如下调用方式

``` js
// 异步
xengine.模块名.方法({
   {...args},
    success: fucntion(result) {
        // 成功回调
    },
    error: fucntion(error) {
        // 失败回调
    }
});
// 或者使用 promise 
xengine.模块名.方法({
    参数1: "",
    参数2: ""})
.then(result=>{})
.catch(error=>{})


// 同步
try {
  var result = xengine.模块名.方法({
      参数1: "",
      参数2: ""
  });
}catch (e){
  
}

```

**约束说明**

* 所有接口一定支持异步调用, 部分支持同步调用
* 接收一个`object`类型的参数
* 成功回调`success`
  * 通过`result`获取成功数据
  * 回调函数的触发时机由具体的API决定，有的API是调用时即可回调（短期），有的是某个事件触发后才被回调（长期）
* 失败回调`error`，所有的API调用错误都会走失败回调



iOS 与 android 端将需要根据 js 端的规则做实现. 

> 为什么以 js 为标准? 因为只要涉及到使用组件, 一定会调用到 js, 而且有可能组件的原生实现只有 iOS 端, 而还缺少 android 端.





## 组件扫描与注册



iOS/android 里的组件实现类以 `__xengine__module_` 开头， 如 `__xengine__module_bluetooth`,  以供 iOS/android 自动注册用。

### xengine__module_BaseModule 类

是所有组件的基类, 定义了组件的通用方法, 基础方法现有(伪代码)

``` oc 

// 子类的 moduleId / namespace
- (string) moduleId {throw exception("子类必须实现")};

// 组件在被回调时, 触发的顺序,越小越早触发
- (int)    order{return 0;};

// 在所有组件都初始化完后, 按照 order 的顺序, 引擎回调通知, 这里可以手动将模块依赖的 protocol/interface 注入.
-(void) onAllMoudlesInited(Engine* engine);
```



> protocol 与 interface 在这里是一个意思.

### java

组件加载逻辑

- 所以组件都放在 com.zkty.modules.loaded 包下
- 扫描  com.zkty.modules.loaded 包下所有类, 
  - 如果类继承自  xengine__module_BaseModule, 则认为是 组件类, 加入 modules 
    - 实例化, 并跟踪特殊接口类
  - 如果没继承,跳过
- 遍历 modules, 调用  xengine__module_BaseModule::onAllMoudlesInited;
  - 组件通过 engine.getModuleByProtocol(protocol_name) 得到依赖的 interface.



modules 可响应系统事件(app生命周期,消息事件,等):  模块类必须实现相应接口

- 在系统事件发生的地方, 遍历 modules. 调用相应生命周期接口, 按照 order 的顺序.
- 



浏览器池初始化逻辑

- 创建 WebViewPool 单例

  

浏览器池使用逻辑:

- 在视图 controller 控制器初始化时,从池里拿到未使用的 webview.



WebViewPool 类声明:

```
public class WebViewPool {
	static WebViewPool sharedInstance();
	webview peekNextUnusedWebViewFromPool();
	webview getUnusedWebViewFromPool();
	void utbackWebViewIntoPool();
}
```

