# 以开发 UI 模块为例

## 整体流程

1. git clone [模块模板](https://www.github.com/zk4/x-engine-module-template) 到本地命名为 x-engine-module-ui, (将远程分支命名为 origin)
  ``` bash
  git clone https://www.github.com/zk4/x-engine-module-template -o template  x-engine-module-ui
  ```
2. 在 github 上创建新的 git 仓库, 命名为 `x-engine-module-ui`, 推送本地 master 分支到远程
  ``` bash
  git remote add origin git@github.com:zk4/x-engine-module-ui.git
  git push --set-upstream origin master
  ```

2. 以 js 端为准, 统一接口名称, **文档化到 README.md**, 以供各端有统一参考, 将文档远程链接到 x-engine-doc  

   ``` json
   [{remoteMD}](https://raw.githubusercontent.com/zk4/x-engine-module-ui/master/README.md?token=AAHTKQR3MB2FAWDNWYNV7SS7D2CXS)
   ```
  >  去掉上面的{}


3. 各端各自开发逻辑,  **一定要有 JS 的逻辑, 至少要有一个 iOS 或 android 端的逻辑.**
4. **在完成相应端测试后, 打上 git tag [版本](./docs/modules/组件-规范.md#版本), 将相应端代码打包到私库** (暂行)

> 在 CI 系统构建完成后, 最后一步将代码推送到 CI 系统, 由 CI 跑测试与引擎的集成度, 与代码覆盖率, 代码覆盖率低于90% 标准将被拒绝发布组件.
>
> 组件 README.md 将会自动集成到[组件仓库].

​    

## JS 

### 修改 package.json

``` json
{
  "name": "@zk4/nav",   // js 组件名
  "version": "1.0.0",   // js 组件版本
  "description": "",
  "main": "src/index.js", // 打包入口文件
  "repository": {
    "type": "git",
    "url": "ssh://git@github.com/zk4/x-engine-npm.git"  // 私库地址
  },
  "scripts": {
    "dev": "webpack-dev-server --mode development --open --hot",
    "build": "webpack --mode production",
    "build:with-prod-config": "webpack  --config webpack.prod.js"
  },
  "author": "zk4",
  "license": "ISC",
  "devDependencies": {
    "@babel/core": "^7.10.4",
    "@babel/preset-env": "^7.10.4",
    "babel-loader": "^8.1.0",
    "css-loader": "^3.6.0",
    "file-loader": "^1.1.11",
    "html-webpack-plugin": "^4.3.0",
    "style-loader": "^1.2.1",
    "webpack": "^4.43.0",
    "webpack-cli": "^3.3.12",
    "webpack-dev-server": "^3.11.0",
    "webpack-merge": "^5.1.4"
  },
  "dependencies": {
    "@zk4/xengine": "^1.0.9"  //依赖的 js 引擎
  }
}

```

> 如果是上传到私库， 请参考     [私地址-npm 章节](./docs/modules/组件-仓库.md#npm)





### 开发技巧

#### 版本与更新

原则很简单，版本号由 <大版本>.<中版本>.<小版本> 构成.

能过 ~ ^ 管理最常见, 大版本是没法自动管理的. 只针对后面两个.

~ 找最大的小版本号 当 npm install  xxx  ~1.15.2 时, 那可能下载到 1.15.99 的包.

^ 找最小的大版本号 当 npm install  xxx  ^3.3.4 时, 那可能下载到 3.99.99 的包.

举例：

![image-20200724124944579](assets/image-20200724124944579.png)

首先要理解, node 这样做的好处.

如果你用 ~, 则保证了 bug 能及时修复,也能及时用上.

如果用 ^, 保证了功能的及时更新,且能兼容.  (中版本号必须保证兼容性)

怎么着你的代码都是能依赖他们跑的.



更新的时候,直接 

```
npm update
```

npm update 会尊重 ~ ^ 的规则. 推荐使用




#### npm link

如果要频繁更改依赖的 node package，则可以使用 npm link 本地化加速修改。在定型后，统一做提交。 这样就不会总是在升级版本。



## IOS

### 组件自动注册

在 iOS 里

以 `__xengine__module_` 为类名开头。 组件则会自动注册。

创建类 继承 `xengine__module_BaseModule`。例如：`__xengine__module_UIModule`

#### 开发

在.m文件中 重写父类方法

```objective-c
- (NSString *)moduleId
{
    return @"模块id";
}
```

在回调方法中接收 数据 并处理

	异步方法

```objc
- (void)funcName:(NSString *)jsonString complate:(XEngineCallBack)completionHandler
{
  // funcName 函数名称（方法名）
  // jsonString js传过来的数据。是个 json串 需要解析使用
  // 可以使用sdk 提供的解析方法 也可以自己解析
  NSDictionary *param = [JSONToDictionary toDictionary:jsonString];
    if (param)
    {
    }
  
  
  // completionHandler 回调block
   //如果js需要 参数回调需要调用这个block 把数据回调给js
  // typedef void (^XEngineCallBack)(NSString * _Nullable result,BOOL complete);
  	NSString *jsonStr = [JSONToDictionary toString:result];
		completionHandler(jsonStr, YES);
}
```






funcName 请参考模块 API表 [模块API表](https://github.com/lgy881228/docs/blob/master/document_js/UI模块使用文档.md)

	同步方法

```objective-c
- (id) funcName:(NSString *) jsonString
{
  // funcName 函数名称（方法名）
  // jsonString js传过来的数据。是个 json串 需要解析使用
  // 可以使用sdk 提供的解析方法 也可以自己解析 方法见 “异步方法”
    return jsonString;
}
```

## android
